#!/usr/bin/env python3
import json

# Criar a estrutura do notebook
notebook = {
    'cells': [
        {
            'cell_type': 'code',
            'metadata': {'title': '# üå± EcoScan: Assistente de Reciclagem e Compostagem com IA'},
            'source': '# @title # üå± EcoScan: Assistente de Reciclagem e Compostagem com IA\n\n"""\nEcoScan: Assistente de Reciclagem e Compostagem com IA\nDesenvolvido como parte do projeto de IA com Google Gemini\n\nEste notebook implementa um assistente inteligente que utiliza a API do Gemini\npara identificar res√≠duos atrav√©s de imagens e fornecer orienta√ß√µes personalizadas\nsobre como recicl√°-los ou compost√°-los corretamente.\n"""\n\n# Instala√ß√£o das bibliotecas necess√°rias\n!pip install google-generativeai pillow matplotlib folium pandas ipywidgets\n\n# Importa√ß√£o das bibliotecas\nimport os\nimport io\nimport base64\nimport requests\nimport json\nimport google.generativeai as genai\nfrom PIL import Image\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport folium\nfrom IPython.display import display, HTML, Image as IPImage\nfrom google.colab import files\nimport numpy as np\nimport ipywidgets as widgets\nfrom google.colab import output',
            'execution_count': None,
            'outputs': []
        },
        {
            'cell_type': 'code',
            'metadata': {'title': '## Configura√ß√£o da API Gemini'},
            'source': '# @title ## Configura√ß√£o da API Gemini\n# @markdown Insira sua chave de API do Google AI Studio\n\n# Widget para inser√ß√£o da chave API\napi_key = "" # @param {type:"string"}\n\n# Configura√ß√£o da API Gemini\ngenai.configure(api_key=api_key)\n\n# Verifica√ß√£o da configura√ß√£o\ntry:\n    # Teste simples para verificar se a API est√° funcionando\n    model = genai.GenerativeModel(\'gemini-pro\')\n    response = model.generate_content("Ol√°, voc√™ pode me ajudar com reciclagem?")\n    print("‚úÖ API Gemini configurada com sucesso!")\n    print(f"Resposta de teste: {response.text[:100]}...")\nexcept Exception as e:\n    print("‚ùå Erro na configura√ß√£o da API Gemini:")\n    print(e)\n    print("\\nPor favor, verifique sua chave de API e tente novamente.")\n    print("Voc√™ pode obter uma chave em: https://aistudio.google.com/")',
            'execution_count': None,
            'outputs': []
        },
        {
            'cell_type': 'code',
            'metadata': {'title': '## Upload e Processamento de Imagens'},
            'source': '# @title ## Upload e Processamento de Imagens\n\ndef upload_and_process_image():\n    """\n    Permite ao usu√°rio fazer upload de uma imagem e a processa para an√°lise.\n    \n    Returns:\n        tuple: Imagem processada e imagem original\n    """\n    print("üì§ Fa√ßa upload de uma imagem do res√≠duo que deseja analisar...")\n    uploaded = files.upload()\n    \n    if not uploaded:\n        print("‚ùå Nenhuma imagem foi enviada.")\n        return None, None\n    \n    # Obt√©m o nome do primeiro arquivo enviado\n    file_name = list(uploaded.keys())[0]\n    \n    try:\n        # Abre a imagem com PIL\n        image = Image.open(io.BytesIO(uploaded[file_name]))\n        \n        # Redimensiona a imagem se for muito grande (mantendo a propor√ß√£o)\n        max_size = 1024\n        if max(image.size) > max_size:\n            ratio = max_size / max(image.size)\n            new_size = (int(image.size[0] * ratio), int(image.size[1] * ratio))\n            image = image.resize(new_size, Image.LANCZOS)\n        \n        # Cria uma c√≥pia da imagem original para exibi√ß√£o\n        display_image = image.copy()\n        \n        # Exibe a imagem\n        plt.figure(figsize=(8, 8))\n        plt.imshow(np.array(display_image))\n        plt.axis(\'off\')\n        plt.title(f"Imagem enviada: {file_name}")\n        plt.show()\n        \n        print(f"‚úÖ Imagem \'{file_name}\' processada com sucesso!")\n        return image, display_image\n    \n    except Exception as e:\n        print(f"‚ùå Erro ao processar a imagem: {e}")\n        return None, None',
            'execution_count': None,
            'outputs': []
        },
        {
            'cell_type': 'code',
            'metadata': {'title': '## An√°lise de Imagem com Gemini'},
            'source': '# @title ## An√°lise de Imagem com Gemini\n\ndef analyze_waste_image(image):\n    """\n    Analisa uma imagem de res√≠duo usando o modelo Gemini-Pro-Vision.\n    \n    Args:\n        image: Imagem PIL a ser analisada\n    \n    Returns:\n        dict: Resultado da an√°lise contendo tipo de material, instru√ß√µes e alternativas\n    """\n    if image is None:\n        print("‚ùå Nenhuma imagem v√°lida para an√°lise.")\n        return None\n    \n    try:\n        # Configura o modelo multimodal Gemini-Pro-Vision\n        model = genai.GenerativeModel(\'gemini-pro-vision\')\n        \n        # Prompt detalhado para orientar a an√°lise do modelo\n        prompt = """\n        Analise esta imagem de um res√≠duo e forne√ßa as seguintes informa√ß√µes:\n        \n        1. IDENTIFICA√á√ÉO: Que tipo de material/res√≠duo √© este? Seja espec√≠fico.\n        2. CLASSIFICA√á√ÉO: Este item √© recicl√°vel, compost√°vel, lixo comum ou res√≠duo especial?\n        3. INSTRU√á√ïES DE DESCARTE: Como este item deve ser descartado corretamente? Inclua etapas de prepara√ß√£o (limpeza, desmontagem, etc.) se necess√°rio.\n        4. IMPACTO AMBIENTAL: Qual o impacto ambiental deste tipo de res√≠duo quando descartado incorretamente?\n        5. ALTERNATIVAS SUSTENT√ÅVEIS: Existem alternativas mais sustent√°veis para este item? Sugira pelo menos 2 op√ß√µes.\n        \n        Formate sua resposta em JSON com as seguintes chaves: \n        "material", "classificacao", "instrucoes_descarte", "impacto_ambiental", "alternativas_sustentaveis"\n        """\n        \n        # Gera a resposta do modelo\n        response = model.generate_content([prompt, image])\n        \n        # Extrai o texto da resposta\n        response_text = response.text\n        \n        # Tenta extrair o JSON da resposta\n        try:\n            # Encontra o in√≠cio e fim do JSON na resposta\n            json_start = response_text.find(\'{\')\n            json_end = response_text.rfind(\'}\') + 1\n            \n            if json_start >= 0 and json_end > json_start:\n                json_str = response_text[json_start:json_end]\n                result = json.loads(json_str)\n                print("‚úÖ An√°lise conclu√≠da com sucesso!")\n                return result\n            else:\n                # Se n√£o encontrar JSON, tenta estruturar a resposta manualmente\n                print("‚ö†Ô∏è Formato JSON n√£o detectado na resposta. Processando texto...")\n                \n                # Estrutura b√°sica para resultado\n                result = {\n                    "material": "N√£o identificado",\n                    "classificacao": "N√£o identificado",\n                    "instrucoes_descarte": "N√£o dispon√≠vel",\n                    "impacto_ambiental": "N√£o dispon√≠vel",\n                    "alternativas_sustentaveis": []\n                }\n                \n                # Extrai informa√ß√µes do texto da resposta\n                if "IDENTIFICA√á√ÉO" in response_text:\n                    material_section = response_text.split("IDENTIFICA√á√ÉO:")[1].split("\\n")[0].strip()\n                    result["material"] = material_section\n                \n                if "CLASSIFICA√á√ÉO" in response_text:\n                    class_section = response_text.split("CLASSIFICA√á√ÉO:")[1].split("\\n")[0].strip()\n                    result["classificacao"] = class_section\n                \n                if "INSTRU√á√ïES DE DESCARTE" in response_text:\n                    instr_section = response_text.split("INSTRU√á√ïES DE DESCARTE:")[1].split("IMPACTO AMBIENTAL")[0].strip()\n                    result["instrucoes_descarte"] = instr_section\n                \n                if "IMPACTO AMBIENTAL" in response_text:\n                    impact_section = response_text.split("IMPACTO AMBIENTAL:")[1].split("ALTERNATIVAS SUSTENT√ÅVEIS")[0].strip()\n                    result["impacto_ambiental"] = impact_section\n                \n                if "ALTERNATIVAS SUSTENT√ÅVEIS" in response_text:\n                    alt_section = response_text.split("ALTERNATIVAS SUSTENT√ÅVEIS:")[1].strip()\n                    result["alternativas_sustentaveis"] = [alt.strip() for alt in alt_section.split("-") if alt.strip()]\n                \n                print("‚úÖ An√°lise processada a partir do texto!")\n                return result\n        \n        except Exception as e:\n            print(f"‚ö†Ô∏è Erro ao processar JSON: {e}")\n            print("Retornando resposta em texto bruto...")\n            return {"resposta_completa": response_text}\n    \n    except Exception as e:\n        print(f"‚ùå Erro na an√°lise da imagem: {e}")\n        return None',
            'execution_count': None,
            'outputs': []
        },
        {
            'cell_type': 'code',
            'metadata': {'title': '## Base de Conhecimento: Pontos de Coleta'},
            'source': '# @title ## Base de Conhecimento: Pontos de Coleta\n\ndef get_collection_points(material_type, user_location=None):\n    """\n    Retorna pontos de coleta adequados para o tipo de material.\n    \n    Args:\n        material_type (str): Tipo de material/classifica√ß√£o\n        user_location (tuple, optional): Localiza√ß√£o do usu√°rio (latitude, longitude)\n    \n    Returns:\n        list: Lista de pontos de coleta\n    """\n    # Base de conhecimento simulada - em uma aplica√ß√£o real, isso seria uma API ou banco de dados\n    collection_points = {\n        "recicl√°vel": [\n            {"nome": "Cooperativa ReciclaVida", "tipo": "Cooperativa de reciclagem", \n             "materiais": ["papel", "pl√°stico", "metal", "vidro"], \n             "endereco": "Av. Sustent√°vel, 123", "lat": -23.550520, "lng": -46.633308},\n            {"nome": "Ecoponto Municipal", "tipo": "Ponto de entrega volunt√°ria", \n             "materiais": ["papel", "pl√°stico", "metal", "vidro", "√≥leo de cozinha"], \n             "endereco": "Rua Ecol√≥gica, 456", "lat": -23.557920, "lng": -46.639825},\n            {"nome": "Supermercado Verde", "tipo": "Ponto de entrega em supermercado", \n             "materiais": ["pl√°stico", "papel", "metal"], \n             "endereco": "Av. das √Årvores, 789", "lat": -23.543430, "lng": -46.642230}\n        ],\n        "compost√°vel": [\n            {"nome": "Horta Comunit√°ria Central", "tipo": "Composteira comunit√°ria", \n             "materiais": ["restos de alimentos", "folhas", "borra de caf√©"], \n             "endereco": "Pra√ßa das Flores, s/n", "lat": -23.553240, "lng": -46.636550},\n            {"nome": "Projeto Composta SP", "tipo": "Composteira municipal", \n             "materiais": ["res√≠duos org√¢nicos", "podas de jardim"], \n             "endereco": "Rua das Sementes, 321", "lat": -23.561320, "lng": -46.631240}\n        ],\n        "especial": [\n            {"nome": "Centro de Reciclagem Tecnol√≥gica", "tipo": "Descarte de eletr√¥nicos", \n             "materiais": ["eletr√¥nicos", "pilhas", "baterias", "l√¢mpadas"], \n             "endereco": "Av. da Tecnologia, 987", "lat": -23.548720, "lng": -46.638120},\n            {"nome": "Farm√°cia EcoSa√∫de", "tipo": "Descarte de medicamentos", \n             "materiais": ["medicamentos vencidos"], \n             "endereco": "Rua da Sa√∫de, 654", "lat": -23.559840, "lng": -46.634670}\n        ]\n    }\n    \n    # Determina a categoria apropriada com base no tipo de material\n    category = "recicl√°vel"  # categoria padr√£o\n    \n    material_lower = material_type.lower()\n    if any(term in material_lower for term in ["org√¢nico", "compost√°vel", "compost", "alimento"]):\n        category = "compost√°vel"\n    elif any(term in material_lower for term in ["especial", "eletr√¥nico", "t√≥xico", "perigoso", "pilha", "bateria", "l√¢mpada", "medicamento"]):\n        category = "especial"\n    \n    # Retorna os pontos de coleta para a categoria identificada\n    points = collection_points.get(category, collection_points["recicl√°vel"])\n    \n    # Adiciona dist√¢ncia simulada se a localiza√ß√£o do usu√°rio for fornecida\n    if user_location:\n        for point in points:\n            # C√°lculo simplificado de dist√¢ncia (em uma aplica√ß√£o real, usaria a API do Google Maps)\n            lat_diff = abs(user_location[0] - point["lat"])\n            lng_diff = abs(user_location[1] - point["lng"])\n            point["distancia"] = round(111.11 * (lat_diff**2 + lng_diff**2)**0.5, 2)  # km aproximados\n    \n    return points',
            'execution_count': None,
            'outputs': []
        },
        {
            'cell_type': 'code',
            'metadata': {'title': '## C√°lculo de Impacto Ambiental'},
            'source': '# @title ## C√°lculo de Impacto Ambiental\n\ndef calculate_environmental_impact(material, weight=0.1):\n    """\n    Calcula o impacto ambiental positivo do descarte correto.\n    \n    Args:\n        material (str): Tipo de material\n        weight (float): Peso estimado em kg (padr√£o: 0.1kg)\n    \n    Returns:\n        dict: M√©tricas de impacto ambiental\n    """\n    # Base de conhecimento com fatores de impacto por kg de material\n    impact_factors = {\n        "pl√°stico": {\n            "co2_evitado": 6.0,  # kg de CO2 evitado por kg de pl√°stico reciclado\n            "agua_economizada": 100.0,  # litros de √°gua economizados\n            "energia_economizada": 5.0,  # kWh de energia economizada\n            "espaco_aterro": 0.05  # m¬≥ de espa√ßo em aterro economizado\n        },\n        "papel": {\n            "co2_evitado": 3.5,\n            "agua_economizada": 50.0,\n            "energia_economizada": 4.0,\n            "espaco_aterro": 0.03\n        },\n        "vidro": {\n            "co2_evitado": 0.3,\n            "agua_economizada": 15.0,\n            "energia_economizada": 0.3,\n            "espaco_aterro": 0.02\n        },\n        "metal": {\n            "co2_evitado": 9.0,\n            "agua_economizada": 40.0,\n            "energia_economizada": 14.0,\n            "espaco_aterro": 0.04\n        },\n        "org√¢nico": {\n            "co2_evitado": 0.5,\n            "agua_economizada": 5.0,\n            "energia_economizada": 0.1,\n            "espaco_aterro": 0.01,\n            "adubo_gerado": 0.3  # kg de adubo gerado por kg de res√≠duo org√¢nico\n        },\n        "eletr√¥nico": {\n            "co2_evitado": 20.0,\n            "agua_economizada": 200.0,\n            "energia_economizada": 25.0,\n            "espaco_aterro": 0.02,\n            "metais_recuperados": 0.1  # kg de metais recuperados\n        }\n    }\n    \n    # Identifica a categoria do material\n    material_lower = material.lower()\n    category = "pl√°stico"  # categoria padr√£o\n    \n    if any(term in material_lower for term in ["papel", "papel√£o", "jornal", "revista"]):\n        category = "papel"\n    elif any(term in material_lower for term in ["vidro", "garrafa"]):\n        category = "vidro"\n    elif any(term in material_lower for term in ["metal", "alum√≠nio", "lata", "a√ßo"]):\n        category = "metal"\n    elif any(term in material_lower for term in ["org√¢nico", "comida", "alimento", "resto"]):\n        category = "org√¢nico"\n    elif any(term in material_lower for term in ["eletr√¥nico", "bateria", "pilha", "computador", "celular"]):\n        category = "eletr√¥nico"\n    \n    # Obt√©m os fatores de impacto para a categoria\n    factors = impact_factors.get(category, impact_factors["pl√°stico"])\n    \n    # Calcula o impacto com base no peso\n    impact = {}\n    for key, value in factors.items():\n        impact[key] = round(value * weight, 3)\n    \n    # Adiciona equival√™ncias para facilitar a compreens√£o\n    equivalents = {}\n    \n    if "co2_evitado" in impact:\n        # Equival√™ncia de CO2: km n√£o dirigidos de carro (0.2 kg CO2/km)\n        equivalents["km_carro_evitados"] = round(impact["co2_evitado"] / 0.2, 1)\n    \n    if "agua_economizada" in impac
(Content truncated due to size limit. Use line ranges to read in chunks)