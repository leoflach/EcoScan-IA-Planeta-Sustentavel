# EcoScan: Notebook do Google Colab

Este arquivo simula o notebook do Google Colab que seria criado para o projeto EcoScan. Em um ambiente real, este conte√∫do seria copiado para um notebook no Google Colab.

```python
# @title # üå± EcoScan: Assistente de Reciclagem e Compostagem com IA

"""
EcoScan: Assistente de Reciclagem e Compostagem com IA
Desenvolvido como parte do projeto de IA com Google Gemini

Este notebook implementa um assistente inteligente que utiliza a API do Gemini
para identificar res√≠duos atrav√©s de imagens e fornecer orienta√ß√µes personalizadas
sobre como recicl√°-los ou compost√°-los corretamente.
"""

# Instala√ß√£o das bibliotecas necess√°rias
!pip install google-generativeai pillow matplotlib folium pandas ipywidgets

# Importa√ß√£o das bibliotecas
import os
import io
import base64
import requests
import json
import google.generativeai as genai
from PIL import Image
import matplotlib.pyplot as plt
import pandas as pd
import folium
from IPython.display import display, HTML, Image as IPImage
from google.colab import files
import numpy as np
import ipywidgets as widgets
from google.colab import output

# @title ## Configura√ß√£o da API Gemini
# @markdown Insira sua chave de API do Google AI Studio

# Widget para inser√ß√£o da chave API
api_key = "" # @param {type:"string"}

# Configura√ß√£o da API Gemini
genai.configure(api_key=api_key)

# Verifica√ß√£o da configura√ß√£o
try:
    # Teste simples para verificar se a API est√° funcionando
    model = genai.GenerativeModel('gemini-pro')
    response = model.generate_content("Ol√°, voc√™ pode me ajudar com reciclagem?")
    print("‚úÖ API Gemini configurada com sucesso!")
    print(f"Resposta de teste: {response.text[:100]}...")
except Exception as e:
    print("‚ùå Erro na configura√ß√£o da API Gemini:")
    print(e)
    print("\nPor favor, verifique sua chave de API e tente novamente.")
    print("Voc√™ pode obter uma chave em: https://aistudio.google.com/")

# @title ## Upload e Processamento de Imagens

def upload_and_process_image():
    """
    Permite ao usu√°rio fazer upload de uma imagem e a processa para an√°lise.
    
    Returns:
        tuple: Imagem processada e imagem original
    """
    print("üì§ Fa√ßa upload de uma imagem do res√≠duo que deseja analisar...")
    uploaded = files.upload()
    
    if not uploaded:
        print("‚ùå Nenhuma imagem foi enviada.")
        return None, None
    
    # Obt√©m o nome do primeiro arquivo enviado
    file_name = list(uploaded.keys())[0]
    
    try:
        # Abre a imagem com PIL
        image = Image.open(io.BytesIO(uploaded[file_name]))
        
        # Redimensiona a imagem se for muito grande (mantendo a propor√ß√£o)
        max_size = 1024
        if max(image.size) > max_size:
            ratio = max_size / max(image.size)
            new_size = (int(image.size[0] * ratio), int(image.size[1] * ratio))
            image = image.resize(new_size, Image.LANCZOS)
        
        # Cria uma c√≥pia da imagem original para exibi√ß√£o
        display_image = image.copy()
        
        # Exibe a imagem
        plt.figure(figsize=(8, 8))
        plt.imshow(np.array(display_image))
        plt.axis('off')
        plt.title(f"Imagem enviada: {file_name}")
        plt.show()
        
        print(f"‚úÖ Imagem '{file_name}' processada com sucesso!")
        return image, display_image
    
    except Exception as e:
        print(f"‚ùå Erro ao processar a imagem: {e}")
        return None, None

# @title ## An√°lise de Imagem com Gemini

def analyze_waste_image(image):
    """
    Analisa uma imagem de res√≠duo usando o modelo Gemini-Pro-Vision.
    
    Args:
        image: Imagem PIL a ser analisada
    
    Returns:
        dict: Resultado da an√°lise contendo tipo de material, instru√ß√µes e alternativas
    """
    if image is None:
        print("‚ùå Nenhuma imagem v√°lida para an√°lise.")
        return None
    
    try:
        # Configura o modelo multimodal Gemini-Pro-Vision
        model = genai.GenerativeModel('gemini-pro-vision')
        
        # Prompt detalhado para orientar a an√°lise do modelo
        prompt = """
        Analise esta imagem de um res√≠duo e forne√ßa as seguintes informa√ß√µes:
        
        1. IDENTIFICA√á√ÉO: Que tipo de material/res√≠duo √© este? Seja espec√≠fico.
        2. CLASSIFICA√á√ÉO: Este item √© recicl√°vel, compost√°vel, lixo comum ou res√≠duo especial?
        3. INSTRU√á√ïES DE DESCARTE: Como este item deve ser descartado corretamente? Inclua etapas de prepara√ß√£o (limpeza, desmontagem, etc.) se necess√°rio.
        4. IMPACTO AMBIENTAL: Qual o impacto ambiental deste tipo de res√≠duo quando descartado incorretamente?
        5. ALTERNATIVAS SUSTENT√ÅVEIS: Existem alternativas mais sustent√°veis para este item? Sugira pelo menos 2 op√ß√µes.
        
        Formate sua resposta em JSON com as seguintes chaves: 
        "material", "classificacao", "instrucoes_descarte", "impacto_ambiental", "alternativas_sustentaveis"
        """
        
        # Gera a resposta do modelo
        response = model.generate_content([prompt, image])
        
        # Extrai o texto da resposta
        response_text = response.text
        
        # Tenta extrair o JSON da resposta
        try:
            # Encontra o in√≠cio e fim do JSON na resposta
            json_start = response_text.find('{')
            json_end = response_text.rfind('}') + 1
            
            if json_start >= 0 and json_end > json_start:
                json_str = response_text[json_start:json_end]
                result = json.loads(json_str)
                print("‚úÖ An√°lise conclu√≠da com sucesso!")
                return result
            else:
                # Se n√£o encontrar JSON, tenta estruturar a resposta manualmente
                print("‚ö†Ô∏è Formato JSON n√£o detectado na resposta. Processando texto...")
                
                # Estrutura b√°sica para resultado
                result = {
                    "material": "N√£o identificado",
                    "classificacao": "N√£o identificado",
                    "instrucoes_descarte": "N√£o dispon√≠vel",
                    "impacto_ambiental": "N√£o dispon√≠vel",
                    "alternativas_sustentaveis": []
                }
                
                # Extrai informa√ß√µes do texto da resposta
                if "IDENTIFICA√á√ÉO" in response_text:
                    material_section = response_text.split("IDENTIFICA√á√ÉO:")[1].split("\n")[0].strip()
                    result["material"] = material_section
                
                if "CLASSIFICA√á√ÉO" in response_text:
                    class_section = response_text.split("CLASSIFICA√á√ÉO:")[1].split("\n")[0].strip()
                    result["classificacao"] = class_section
                
                if "INSTRU√á√ïES DE DESCARTE" in response_text:
                    instr_section = response_text.split("INSTRU√á√ïES DE DESCARTE:")[1].split("IMPACTO AMBIENTAL")[0].strip()
                    result["instrucoes_descarte"] = instr_section
                
                if "IMPACTO AMBIENTAL" in response_text:
                    impact_section = response_text.split("IMPACTO AMBIENTAL:")[1].split("ALTERNATIVAS SUSTENT√ÅVEIS")[0].strip()
                    result["impacto_ambiental"] = impact_section
                
                if "ALTERNATIVAS SUSTENT√ÅVEIS" in response_text:
                    alt_section = response_text.split("ALTERNATIVAS SUSTENT√ÅVEIS:")[1].strip()
                    result["alternativas_sustentaveis"] = [alt.strip() for alt in alt_section.split("-") if alt.strip()]
                
                print("‚úÖ An√°lise processada a partir do texto!")
                return result
        
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao processar JSON: {e}")
            print("Retornando resposta em texto bruto...")
            return {"resposta_completa": response_text}
    
    except Exception as e:
        print(f"‚ùå Erro na an√°lise da imagem: {e}")
        return None

# @title ## Base de Conhecimento: Pontos de Coleta

def get_collection_points(material_type, user_location=None):
    """
    Retorna pontos de coleta adequados para o tipo de material.
    
    Args:
        material_type (str): Tipo de material/classifica√ß√£o
        user_location (tuple, optional): Localiza√ß√£o do usu√°rio (latitude, longitude)
    
    Returns:
        list: Lista de pontos de coleta
    """
    # Base de conhecimento simulada - em uma aplica√ß√£o real, isso seria uma API ou banco de dados
    collection_points = {
        "recicl√°vel": [
            {"nome": "Cooperativa ReciclaVida", "tipo": "Cooperativa de reciclagem", 
             "materiais": ["papel", "pl√°stico", "metal", "vidro"], 
             "endereco": "Av. Sustent√°vel, 123", "lat": -23.550520, "lng": -46.633308},
            {"nome": "Ecoponto Municipal", "tipo": "Ponto de entrega volunt√°ria", 
             "materiais": ["papel", "pl√°stico", "metal", "vidro", "√≥leo de cozinha"], 
             "endereco": "Rua Ecol√≥gica, 456", "lat": -23.557920, "lng": -46.639825},
            {"nome": "Supermercado Verde", "tipo": "Ponto de entrega em supermercado", 
             "materiais": ["pl√°stico", "papel", "metal"], 
             "endereco": "Av. das √Årvores, 789", "lat": -23.543430, "lng": -46.642230}
        ],
        "compost√°vel": [
            {"nome": "Horta Comunit√°ria Central", "tipo": "Composteira comunit√°ria", 
             "materiais": ["restos de alimentos", "folhas", "borra de caf√©"], 
             "endereco": "Pra√ßa das Flores, s/n", "lat": -23.553240, "lng": -46.636550},
            {"nome": "Projeto Composta SP", "tipo": "Composteira municipal", 
             "materiais": ["res√≠duos org√¢nicos", "podas de jardim"], 
             "endereco": "Rua das Sementes, 321", "lat": -23.561320, "lng": -46.631240}
        ],
        "especial": [
            {"nome": "Centro de Reciclagem Tecnol√≥gica", "tipo": "Descarte de eletr√¥nicos", 
             "materiais": ["eletr√¥nicos", "pilhas", "baterias", "l√¢mpadas"], 
             "endereco": "Av. da Tecnologia, 987", "lat": -23.548720, "lng": -46.638120},
            {"nome": "Farm√°cia EcoSa√∫de", "tipo": "Descarte de medicamentos", 
             "materiais": ["medicamentos vencidos"], 
             "endereco": "Rua da Sa√∫de, 654", "lat": -23.559840, "lng": -46.634670}
        ]
    }
    
    # Determina a categoria apropriada com base no tipo de material
    category = "recicl√°vel"  # categoria padr√£o
    
    material_lower = material_type.lower()
    if any(term in material_lower for term in ["org√¢nico", "compost√°vel", "compost", "alimento"]):
        category = "compost√°vel"
    elif any(term in material_lower for term in ["especial", "eletr√¥nico", "t√≥xico", "perigoso", "pilha", "bateria", "l√¢mpada", "medicamento"]):
        category = "especial"
    
    # Retorna os pontos de coleta para a categoria identificada
    points = collection_points.get(category, collection_points["recicl√°vel"])
    
    # Adiciona dist√¢ncia simulada se a localiza√ß√£o do usu√°rio for fornecida
    if user_location:
        for point in points:
            # C√°lculo simplificado de dist√¢ncia (em uma aplica√ß√£o real, usaria a API do Google Maps)
            lat_diff = abs(user_location[0] - point["lat"])
            lng_diff = abs(user_location[1] - point["lng"])
            point["distancia"] = round(111.11 * (lat_diff**2 + lng_diff**2)**0.5, 2)  # km aproximados
    
    return points

# @title ## C√°lculo de Impacto Ambiental

def calculate_environmental_impact(material, weight=0.1):
    """
    Calcula o impacto ambiental positivo do descarte correto.
    
    Args:
        material (str): Tipo de material
        weight (float): Peso estimado em kg (padr√£o: 0.1kg)
    
    Returns:
        dict: M√©tricas de impacto ambiental
    """
    # Base de conhecimento com fatores de impacto por kg de material
    impact_factors = {
        "pl√°stico": {
            "co2_evitado": 6.0,  # kg de CO2 evitado por kg de pl√°stico reciclado
            "agua_economizada": 100.0,  # litros de √°gua economizados
            "energia_economizada": 5.0,  # kWh de energia economizada
            "espaco_aterro": 0.05  # m¬≥ de espa√ßo em aterro economizado
        },
        "papel": {
            "co2_evitado": 3.5,
            "agua_economizada": 50.0,
            "energia_economizada": 4.0,
            "espaco_aterro": 0.03
        },
        "vidro": {
            "co2_evitado": 0.3,
            "agua_economizada": 15.0,
            "energia_economizada": 0.3,
            "espaco_aterro": 0.02
        },
        "metal": {
            "co2_evitado": 9.0,
            "agua_economizada": 40.0,
            "energia_economizada": 14.0,
            "espaco_aterro": 0.04
        },
        "org√¢nico": {
            "co2_evitado": 0.5,
            "agua_economizada": 5.0,
            "energia_economizada": 0.1,
            "espaco_aterro": 0.01,
            "adubo_gerado": 0.3  # kg de adubo gerado por kg de res√≠duo org√¢nico
        },
        "eletr√¥nico": {
            "co2_evitado": 20.0,
            "agua_economizada": 200.0,
            "energia_economizada": 25.0,
            "espaco_aterro": 0.02,
            "metais_recuperados": 0.1  # kg de metais recuperados
        }
    }
    
    # Identifica a categoria do material
    material_lower = material.lower()
    category = "pl√°stico"  # categoria padr√£o
    
    if any(term in material_lower for term in ["papel", "papel√£o", "jornal", "revista"]):
        category = "papel"
    elif any(term in material_lower for term in ["vidro", "garrafa"]):
        category = "vidro"
    elif any(term in material_lower for term in ["metal", "alum√≠nio", "lata", "a√ßo"]):
        category = "metal"
    elif any(term in material_lower for term in ["org√¢nico", "comida", "alimento", "resto"]):
        category = "org√¢nico"
    elif any(term in material_lower for term in ["eletr√¥nico", "bateria", "pilha", "computador", "celular"]):
        category = "eletr√¥nico"
    
    # Obt√©m os fatores de impacto para a categoria
    factors = impact_factors.get(category, impact_factors["pl√°stico"])
    
    # Calcula o impacto com base no peso
    impact = {}
    for key, value in factors.items():
        impact[key] = round(value * weight, 3)
    
    # Adiciona equival√™ncias para facilitar a compreens√£o
    equivalents = {}
    
    if "co2_evitado" in impact:
        # Equival√™ncia de CO2: km n√£o dirigidos de carro (0.2 kg CO2/km)
        equivalents["km_carro_evitados"] = round(impact["co2_evitado"] / 0.2, 1)
    
    if "agua_economizada" in impact:
        # Equival√™ncia de √°gua: garrafas de 500ml
        equivalents["garrafas_agua"] = round(impact["agua_economizada"] / 0.5, 1)
    
    if "energia_economizada" in impact:
        # Equival√™ncia de energia: horas de TV (0.1 kWh/hora)
        equivalents["horas_tv"] = round(impact["energia_economizada"] / 0.1, 1)
    
    return {
        "impacto": impact,
        "equivalencias": equivalents,
        "categoria": category
    }

# @title ## Visualiza√ß√£o dos Resultados

def display_results(analysis_result, impact_data, collection_points):
    """
    Exibe os resultados da an√°lise de forma visual e informativa.
    
    Args:
        analysis_result (dict): Resultado da an√°lise da imagem
        impact_data (dict): Dados de impacto ambiental
        collection_points (list): Lista de pontos de coleta
    """
    if not analysis_result:
        print("‚ùå Sem resultados para exibir.")
        return
    
    # Estilo CSS para melhorar a apresenta√ß√£o
    display(HTML("""
    <style>
        .result-container {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 20px auto;
            padding: 20px;
            border-radius: 10px;
            background-color: #f5f9f5;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .section {
            margin-bottom: 20px;
            padding: 15px;
            border-radius: 8px;
            background-color: white;
            box-sh
(Content truncated due to size limit. Use line ranges to read in chunks)